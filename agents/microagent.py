import logging
from typing import List, Dict, Any, Optional, Tuple, Callable
from agents.agent_evaluation import AgentEvaluator
from agents.agent_response import AgentResponse
from agents.agent_similarity import AgentSimilarity
from agents.capabilities import Ability, CodeExecutionAbility, FileSystemAbility, DiffAbility, GitAbility, PythonFunctionAbility
from integrations.llm_wrapper import LLMAPIWrapper
from prompt_management.prompt_evolution import PromptEvolution
from agents.response_extraction import ResponseExtraction
from utils.utility import get_env_variable, time_function, log_exception

logging.basicConfig(level=logging.ERROR, format='%(asctime)s - %(levelname)s - %(message)s')

class MicroAgent:
    """
    The MicroAgent class encapsulates the behavior of a small, purpose-driven agent
    that interacts with the LLM API.
    """

    def __init__(self, initial_prompt: str, purpose: str, depth: int, agent_creator: Any, llm_wrapper: LLMAPIWrapper,
                 abilities: List[Ability], task_decomposition_strategy: TaskDecompositionStrategy,
                 max_depth: int = 3, bootstrap_agent: bool = False, is_prime: bool = False,
                 name: Optional[str] = None):
        """
        Initializes a MicroAgent.

        :param initial_prompt: The initial prompt for the agent.
        :param purpose: The purpose of the agent.
        :param depth: The depth of the agent in the agent hierarchy.
        :param agent_creator: The creator/manager of the agent.
        :param llm_wrapper: The LLM API wrapper.
        :param abilities: List of abilities the agent has.
        :param task_decomposition_strategy: Strategy for decomposing tasks.
        :param max_depth: Maximum depth for recursive calls.
        :param bootstrap_agent: Flag indicating if the agent is a bootstrap agent.
        :param is_prime: Flag indicating if the agent is a prime agent.
        :param name: Optional name for the agent.
        """
        self.dynamic_prompt = initial_prompt
        self.purpose = purpose
        self.depth = depth
        self.max_depth = max_depth
        self.usage_count = 0
        self.working_agent = bootstrap_agent
        self.agent_creator = agent_creator
        self.llm_wrapper = llm_wrapper
        self.evolve_count = 0
        self.number_of_code_executions = 0
        self.current_status: Optional[str] = None
        self.active_agents: Dict[str, str] = {}
        self.last_input: str = ""
        self.is_prime = is_prime
        self.name = name or purpose  # Use purpose as name if not provided
        self.task_decomposition_strategy = task_decomposition_strategy
        self.abilities: Dict[str, Ability] = {ability.__class__.__name__: ability for ability in abilities}

        # Initialize components used by the agent
        self.agent_evaluator = AgentEvaluator(self.llm_wrapper)
        self.agent_responder = AgentResponse(self.llm_wrapper, self.agent_creator, self, agent_creator, depth, self.abilities)
        self.agent_similarity = AgentSimilarity(self.llm_wrapper, self.agent_creator.agents)
        self.prompt_evolver = PromptEvolution(self.llm_wrapper, self.agent_creator)
        self.response_extractor = ResponseExtraction(self.llm_wrapper)

    def update_status(self, status: str):
        """
        Updates the agent's current status.

        :param status: The new status of the agent.
        """
        self.current_status = status
        logging.info(f"Agent {self.name} status updated to: {status}")

    def update_active_agents(self, calling_agent: str, called_agent: Optional[str] = None):
        """
        Updates the tree view of active agents.

        :param calling_agent: The name of the calling agent.
        :param called_agent: The name of the called agent.
        """
        if called_agent:
            self.active_agents[calling_agent] = called_agent
        else:
            self.active_agents.pop(calling_agent, None)
        logging.info(f"Active agents updated: {self.active_agents}")

    def get_ability(self, ability_name: str) -> Optional[Ability]:
        """
        Retrieves a specific ability of the agent.

        :param ability_name: The name of the ability to retrieve.
        :return: The ability if found, otherwise None.
        """
        return self.abilities.get(ability_name)

    @time_function
    def respond(self, input_text: str) -> str:
        """
        Generates a response to the given input text.

        :param input_text: The input text to respond to.
        :return: The response generated by the agent.
        """
        self.last_input = input_text
        try:
            self.update_status('Planning')
            response, conversation, solution, iterations = self.agent_responder.generate_response(
                input_text, self.dynamic_prompt, self.max_depth
            )

            if not self.working_agent:
                if iterations > 2:
                    self.evolve_count += 1
                    self.update_status('Evolving prompt')
                    self.dynamic_prompt = self.prompt_evolver.evolve_prompt(
                        input_text, self.dynamic_prompt, response, conversation, solution, self.depth
                    )
                elif solution:
                    self.working_agent = True

            self.update_status('Idle')
            self.update_active_agents(self.name)
            return response
        except Exception as e:
            log_exception(e)
            self.update_status('Error')
            self.update_active_agents(self.name)
            return "An error occurred while generating the response."

    def send_message(self, recipient_agent: "MicroAgent", message: str):
        """
        Sends a message to another agent.

        :param recipient_agent: The agent to send the message to.
        :param message: The message to send.
        """
        recipient_agent.receive_message(self, message)

    def receive_message(self, sender_agent: "MicroAgent", message: str):
        """
        Receives a message from another agent.

        :param sender_agent: The agent that sent the message.
        :param message: The received message.
        """
        # Process the received message
        pass